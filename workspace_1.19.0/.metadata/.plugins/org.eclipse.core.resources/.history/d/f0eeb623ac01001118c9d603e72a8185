#include "i2c_driver.h"

#define OPT3001_ADDR 0x47

void I2C1_Init(void)
{
    /* Enable clocks */
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOBEN;
    RCC->APB1ENR1 |= RCC_APB1ENR1_I2C1EN;

    /* PB8, PB9 Alternate Function mode */
    GPIOB->MODER &= ~((3<<(6*2)) | (3<<(7*2)));
    GPIOB->MODER |=  (2<<(6*2)) | (2<<(7*2));

    GPIOB->OTYPER |= (1<<6) | (1<<7);      // Open-drain
    GPIOB->OSPEEDR |= (3<<(6*2)) | (3<<(7*2));
    GPIOB->PUPDR &= ~((3<<(6*2)) | (3<<(7*2)));

    GPIOB->AFR[1] |= (4<<0) | (4<<4);     // AF4 = I2C

    /* Reset I2C */
    I2C1->CR1 &= ~I2C_CR1_PE;

    /* Timing for 100kHz @ 16 MHz */
    I2C1->TIMINGR = 0x00303D5B;

    I2C1->CR1 |= I2C_CR1_PE;
}

static void I2C_Start(uint8_t addr, uint8_t size, uint8_t dir)
{
    I2C1->CR2 = 0;
    I2C1->CR2 |= (addr << 1);
    I2C1->CR2 |= (size << 16);
    if(dir) I2C1->CR2 |= I2C_CR2_RD_WRN;
    I2C1->CR2 |= I2C_CR2_START;
}

void I2C1_WriteReg(uint8_t devAddr, uint8_t reg, uint8_t data)
{
    I2C_Start(devAddr, 2, 0);

    while(!(I2C1->ISR & I2C_ISR_TXIS));
    I2C1->TXDR = reg;

    while(!(I2C1->ISR & I2C_ISR_TXIS));
    I2C1->TXDR = data;

    while(!(I2C1->ISR & I2C_ISR_TC));
    I2C1->CR2 |= I2C_CR2_STOP;
}

void I2C1_ReadMulti(uint8_t devAddr, uint8_t reg, uint8_t *buf, uint8_t len)
{
    /* Send register address */
    I2C_Start(devAddr, 1, 0);
    while(!(I2C1->ISR & I2C_ISR_TXIS));
    I2C1->TXDR = reg;
    while(!(I2C1->ISR & I2C_ISR_TC));

    /* Restart for read */
    I2C_Start(devAddr, len, 1);

    for(int i=0;i<len;i++)
    {
        while(!(I2C1->ISR & I2C_ISR_RXNE));
        buf[i] = I2C1->RXDR;
    }

    while(!(I2C1->ISR & I2C_ISR_TC));
    I2C1->CR2 |= I2C_CR2_STOP;
}

void OPT3001_Init(void)
{
    // Continuous conversion mode config = 0xC410
    I2C1_WriteReg(OPT3001_ADDR, 0x01, 0xC4);
    I2C1_WriteReg(OPT3001_ADDR, 0x02, 0x10);
}

float OPT3001_ReadLux(void)
{
    uint8_t raw[2];
    uint16_t val, mantissa;
    uint8_t exponent;

    I2C1_ReadMulti(OPT3001_ADDR, 0x00, raw, 2);

    val = (raw[0] << 8) | raw[1];
    exponent = (val >> 12) & 0x0F;
    mantissa = val & 0x0FFF;

    return (0.01 * mantissa) * (1 << exponent);
}
